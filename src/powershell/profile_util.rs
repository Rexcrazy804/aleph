use crate::AlephConfig;
use std::collections::HashMap;
use std::fs::{self, create_dir, create_dir_all};
use std::path::{Path, PathBuf};
use std::process::Command;

pub fn get_profile_path() -> PathBuf {
    let output = Command::new("pwsh")
        .args(["-c", "echo", "$PROFILE"])
        .output()
        .expect("Failed to execute process [is powershell installed?]");

    let profile_path = String::from_utf8(output.stdout).unwrap().trim().to_string();
    PathBuf::from(profile_path)
}

// uninstaller
pub fn remove_from_path(
    config: &AlephConfig,
    package_names: &Vec<&str>,
    inverse: bool,
) -> Result<(), String> {
    let profile_path = get_profile_path();

    let profile_content = fs::read_to_string(&profile_path)
        .map_err(|e| format!("Failed to read PowerShell profile: {e}"))?;
    let mut package_names = package_names.clone();
    if inverse {
        // don't delete these .w.
        package_names.push("7zip");
        package_names.push("wget");
    }

    let search_str: Vec<String> = package_names
        .iter()
        .map(|package| format!("\\{}\\", package.trim()))
        .collect();

    let filtered_lines: Vec<String> = profile_content
        .lines()
        .filter(|line| {
            if !line.contains("$HOME") {
                return true;
            }
            let contains = search_str.iter().filter(|x| line.contains(*x)).count() > 0;
            if inverse {
                contains
            } else {
                !contains
            }
        })
        .map(std::string::ToString::to_string)
        .collect();

    let new_profile = filtered_lines.join("\n");

    fs::write(&profile_path, new_profile)
        .map_err(|e| format!("Failed to update PowerShell profile: {e}"))?;

    Ok(())
}

const DEFAULT_PROFILE: &str = "\
# This file is automatically generated by the package manager.
# for my linux homies uncomment the line below for some peace of mind
# function prompt { \"> \" }
$env:PATH = (
$env:PATH)
# Aleph Environment Variables
";

/// Apends the given ``paths`` to the $env:PATH in the Miscrosoft.PowerShell.prfoile.ps1 file
/// - if the file does not exist a basic template is leveraged
///
/// # Panics
/// - failures to convert the paths to string
///
/// # Errors
/// - IO erros like being unable to write to profile file
pub fn append_to_path(home_dir: &Path, paths: &Vec<PathBuf>) -> std::io::Result<()> {
    let profile_path = get_profile_path();
    let profile_dir = profile_path
        .parent()
        .expect("No parent dir for profile path");
    if let Ok(false) = profile_path.parent().unwrap().try_exists() {
        create_dir_all(profile_dir).expect("Failed to create powershell folder");
    }

    let mut ps_profile = if let Ok(content) = fs::read_to_string(&profile_path) {
        content
    } else {
        println!("FILE DOES NOT EXIST: {profile_path:?}");
        String::from(DEFAULT_PROFILE)
    };

    if !ps_profile.contains("$env:PATH = (") {
        ps_profile.push_str(DEFAULT_PROFILE);
    }

    let mut modified_ps_profile = String::new();
    let mut intermediate_path_buffer: Vec<String> = Vec::new();
    let home_dir_str = home_dir
        .to_str()
        .expect("Failed to convert home_dir into str");

    for path in paths {
        let path = path.to_str().expect("Failed to convert path into str");
        let replaced_path = path.replace(home_dir_str, "$HOME");
        intermediate_path_buffer.push("  \"".to_owned() + &replaced_path + ";\"" + " +");
    }

    let mut paths_entry_flag = false;

    for line in ps_profile.lines() {
        if line.contains("$env:PATH = (") {
            paths_entry_flag = true;
            modified_ps_profile.push_str(&(line.to_owned() + "\n"));
            continue;
        }
        if line.contains("$env:PATH)") {
            paths_entry_flag = false;
            intermediate_path_buffer.sort();
            intermediate_path_buffer.dedup_by(|a, b| {
                if a == b {
                    println!("path {a} already installed ");
                    true
                } else {
                    false
                }
            });
            for line in intermediate_path_buffer.clone() {
                modified_ps_profile.push_str(&(line + "\n"));
            }
        }

        if paths_entry_flag {
            intermediate_path_buffer.push(line.to_owned());
        } else {
            modified_ps_profile.push_str(&(line.to_owned() + "\n"));
        }
    }

    fs::write(profile_path, modified_ps_profile)?;
    Ok(())
}

pub fn append_env_vars(
    home_dir: &Path,
    env_vars_map: &HashMap<String, String>,
    package_dir: &PathBuf,
) -> std::io::Result<()> {
    let profile_path = get_profile_path();
    let profile_dir = profile_path
        .parent()
        .expect("No parent dir for profile path");
    if let Ok(false) = profile_path.parent().unwrap().try_exists() {
        create_dir_all(profile_dir).expect("Failed to create powershell folder");
    }

    let mut ps_profile = if let Ok(content) = fs::read_to_string(&profile_path) {
        content
    } else {
        println!("FILE DOES NOT EXIST: {profile_path:?}");
        String::from(DEFAULT_PROFILE)
    };

    if !ps_profile.contains("$env:PATH = (") {
        ps_profile.push_str(DEFAULT_PROFILE);
    }

    let mut modified_ps_profile = String::new();
    let package_dir = package_dir.clone();
    let package_dir = package_dir.to_str().unwrap();

    let env_vars_ps_string = env_vars_map
        .iter()
        .map(|(var, val)| {
            let val = val.replace("$dir", package_dir);
            format!("$env:{var} = \"{val}\"\n")
        })
        .collect::<Vec<String>>();

    // TODO add dedup support for this
    let mut added_env = false;
    for line in ps_profile.lines() {
        modified_ps_profile.push_str(&(line.to_owned() + "\n"));
        if line.contains("# Aleph Environment Variables") {
            for ps_string in &env_vars_ps_string {
                modified_ps_profile.push_str(ps_string);
            }
            added_env = true;
        }
    }

    if !added_env {
        modified_ps_profile.push_str("# Aleph Environment Variables\n");
        for ps_string in &env_vars_ps_string {
            modified_ps_profile.push_str(ps_string);
        }
    }

    fs::write(profile_path, modified_ps_profile)?;
    Ok(())
}
